#!/usr/bin/env python

import pefile
import sys
import os
import peutils

def file_type(pe_file):
    # Values, as defined by Microsoft: https://learn.microsoft.com/en-us/windows/win32/api/dbghelp/ns-dbghelp-loaded_image
    IMAGE_FILE_DLL = 0x2000
    IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002
    IMAGE_FILE_SYSTEM = 0x1000
    
    if pe_file.FILE_HEADER.Characteristics & IMAGE_FILE_DLL:
        print("File type: DLL")
    elif pe_file.FILE_HEADER.Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE:
        print("File type: EXE")
    elif pe_file.FILE_HEADER.Characteristics & IMAGE_FILE_SYSTEM:
        print("File type: SYS")
    else:
       print("The file is neither of the following: DLL, EXE, SYS")

def number_of_dlls(pe_file):
   counter = 0
   #Traversing through the directory and incrementing
   for entry in pe_file.DIRECTORY_ENTRY_IMPORT:
      counter+=1
   print("The number of imported DLLs: " + (str)(counter))

def number_of_imports(pe_file):
   counter = 0
   #Traversing through the directories, accessing them and incrementing imports
   for entry in pe_file.DIRECTORY_ENTRY_IMPORT:
      for imp in entry.imports:
        counter+=1
   print("The number of total imports: " + (str)(counter))

def compile_time(pe_file):
    compilation_date = pe_file.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split('[')[1][:-1]
    print("Compilation time : " + compilation_date)

def alert_entrypoint(pe_file):
   entry_point = pe_file.OPTIONAL_HEADER.AddressOfEntryPoint + pe_file.OPTIONAL_HEADER.ImageBase
   valid_sections = [".text", ".code", "CODE", "INIT"]
   for section in pe_file.sections:
      section_name = section.Name.decode("utf-8")[:8].strip()
      #Accesing the virtual address through navigating and point through it
      if section.VirtualAddress <= entry_point <= section.VirtualAddress + section.Misc_VirtualSize:
         if section_name not in valid_sections:
            print("Alert: The entry point of the code is not in a valid section [.text, .code, CODE, INIT]")
    

def identify_packers(pe_file):
   signature = peutils.SignatureDatabase('UserDB.TXT')
   matches = signature.match_all(pe_file, ep_only=True, section_start_only=False)
   if matches:
      print(f"The following packer was detected: {matches}")
   else:
      print("No packer detected.")


def calculate_entropy(pe_file):
   for section in pe_file.sections:
      section_dict = section.dump_dict()
      entropy = section.get_entropy()
      section_dict["Entropy"] = entropy
      if entropy == 0.0:
        print(f"Section: {section.Name.decode('utf-8').strip()} is empty.") 
      if entropy > 7.0:
        print(f"ALERT! Section: {section.Name.decode('utf-8').strip()} may be packed or compressed.")
      elif 0.0 < entropy < 7.0:
        print(f"Section: {section.Name.decode('utf-8').strip()} Entropy: {entropy:.4f}")

def verify_checksum(pe_file):
    if pe_file.OPTIONAL_HEADER.CheckSum != pe_file.generate_checksum():
       print("ALERT! PE checksum does not match.")

def dump_resource(pe_file):
    cwd = os.getcwd()
    output_file_path = os.path.join(cwd, 'extracted_resource.txt')
    if hasattr(pe_file, 'DIRECTORY_ENTRY_RESOURCE'):
        for resource_type in pe_file.DIRECTORY_ENTRY_RESOURCE.entries:
            if hasattr(resource_type, 'directory'):
                for resource_id in resource_type.directory.entries:
                    if hasattr(resource_id, 'directory'):
                        for resource_lang in resource_id.directory.entries:
                            # Extract the resource data
                            data_rva = resource_lang.data.struct.OffsetToData
                            size = resource_lang.data.struct.Size
                            resource_data = pe_file.get_data(data_rva, size)
                            
                            # Write to file
                            with open(output_file_path, 'wb') as output_file:
                                output_file.write(resource_data)
                            print(f"Resource was extracted to the file named: {output_file_path}")
                            return
    else:
        print("No resource section found in the PE file.")


def Main():
    if len(sys.argv) != 2:
        print("Usage: python3 file_analysis.py <PE file>")
        sys.exit(1)
    
    file_path = sys.argv[1]
    
    if not os.path.isfile(file_path):
        print(f"Error: '{file_path}' file was not found.")
        sys.exit(1)
    
    pe_file = pefile.PE(file_path) #parses the pe file

    #1. Identify the file type (DLL, EXE, SYS)
    file_type(pe_file)
    #2. Total number of imported DLLs
    number_of_dlls(pe_file)
    #3. Total number of imported functions
    number_of_imports(pe_file)
    #4. Output the compile time
    compile_time(pe_file)
    #5. Alert the user if the entry point of the code is not in the section .text , .code , CODE , INIT
    alert_entrypoint(pe_file)
    #6. Identify packers
    identify_packers(pe_file)

    #7. Calculate the entropy, announce if empty
    calculate_entropy(pe_file)

    #8. Compare optional header file checksum
    verify_checksum(pe_file)

    #9. If there is a resource section, dump the first resource to a file on disk
    dump_resource(pe_file)




if __name__ == "__main__":
    Main()
